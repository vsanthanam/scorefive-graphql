type Query {
    me: User!
    mySavedPlayers: [SavedPlayer!]!
    savedPlayer(id: ID!): SavedPlayer
    myGames: [Game!]!
    game(id: ID!): Game
}

type Mutation {
    createSavedPlayer(displayName: String!): SavedPlayer!
    updateSavedPlayerDisplayName(savedPlayerId: ID!, newDisplayName: String!): SavedPlayer!
    createGame(input: CreateGameInput!): Game!
}

type User implements GameParticipant {
    id: ID!
    displayName: String!
    emailAddress: String
    emailVerified: Boolean!
    createdAt: DateTime!
    updatedAt: DateTime!
    participatingGames: [Game!]!
}

scalar DateTime

type SavedPlayer implements GameParticipant {
    id: ID!
    displayName: String!
    createdAt: DateTime!
    updatedAt: DateTime!
    owner: User!
    participatingGames: [Game!]!
}

interface GameParticipant {
    id: ID!
    displayName: String!
    participatingGames: [Game!]!
}

type AnonymousParticipant implements GameParticipant {
    id: ID!
    displayName: String!
    participatingGames: [Game!]!
}

type Game {
    id: ID!
    owner: User!
    orderedParticipants: [GameParticipant!]!
    scoreLimit: Int
    hands: [Hand!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}

input CreateGameInput {
    scoreLimit: Int!
    gameParticipants: [GameParticipantInput!]!
}

input GameParticipantInput @oneOf {
    userId: String
    savedPlayerId: String
    anonymousParticipantDisplayName: String
}

type Hand {
    id: ID!
    game: Game!
    handNumber: Int!
    scores: [HandScore!]!
}

type HandScore {
    hand: Hand!
    participant: GameParticipant!
    points: Int!
}
